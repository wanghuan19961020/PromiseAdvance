<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>03_promise的api</title>
</head>
<body>
<script>
/*
  1. `Promise` 构造函数： `Promise(excutor) {}`
      * `excutor` 函数：同步执行 `(resolve, reject) => {}`
      * `resolve` 函数：内部定义成功时我们调用的函数 `value => {}`
      * `reject` 函数：内部定义失败时我们调用的函数 `reason => {}`
      * 说明：`excutor` 会在 `Promise` 内部立即同步回调，异步操作在执行器中执行
  2. `Promise.prototype.then` 方法： `(onResolved, onRejected) => {}`
      * `onResolved` 函数：成功的回调函数 `value => {}`
      * `onRejected` 函数：失败的回调函数 `reason => {}`
      * 说明：指定用于得到成功 `value` 的成功回调和用于得到失败 `reason` 失败回调，返回一个新的 `Promise` 对象
  3. `Promise.prototype.catch` 方法： `p.catch(onRejected)`
      * `onRejected` 函数：失败的回调函数 `reason => {}`
      * 说明：`then()` 的语法糖，相当于 `then(undefined, onRejected)`
  4. `Promise.resolve` 方法：`value => {}`
      * `value`： 成功的数据或`promise`对象
      * 说明：返回一个成功/失败的 `promise` 对象
  5. `Promise.rejected` 方法：`reason => {}`
      * `reason`： 失败的原因
      * 说明：返回一个失败的 `promise` 对象
  6. `Promise.all` 方法：`promises => {}`
      * `promises`：包含n个 `promise` 的数组
      * 说明：返回一个新的 `promise`，只有所有的 `promise` 都成功才成功，只要有一个失败了就直接失败
  7. `Promise.race` 方法： `promises => {}`
      * `promises`：包含n个 `promise` 的数组
      * 说明：返回一个新的 `promise`，第一个完成的 `promise` 的结果状态就是最终的结果状态
 */

new Promise((resolve, reject)=>{
  setTimeout(()=>{
    resolve("成功的数据")
    // reject("失败的数据")
  }, 1000)
}).then(
    value => {
      console.log("onResolved()1", value)
    }
).catch(
    reason => {
      console.log("onRejected()1", reason)
    }
)

// 产生一个成功值为1 的promise对象
const p1 = new Promise((resolve, reject)=>{
  resolve(1)
})
const p1_1 = new Promise((resolve, reject)=>{
  setTimeout(()=>{
    resolve(1)
  }, 100)
})
const p2 = Promise.resolve(2) // 语法糖
const p3 = Promise.reject(3)
p1.then(value => { console.log(value) })
p2.then(value => { console.log(value) })
p3.then(null, reason => { console.log(reason) })
p3.catch(reason => { console.log(reason) })

const pAll = Promise.all([p1, p2, p3])
pAll.then(
  value => { console.log("all onResolved()", value) },
  reason => { console.log("all onRejected()", reason) } //all onRejected() 3
)
const pAll2 = Promise.all([p1, p2])
pAll2.then(
    values => { console.log("all onResolved()", values) }, // all onResloved() [1, 2]
    reason => { console.log("all onRejected()", reason) }
)

const pRace = Promise.race([p1, p2, p3])
pRace.then(
    value => { console.log("all onResolved()", value) }, // all onResolved() 1
    reason => { console.log("all onRejected()", reason) }
)
const pRace1 = Promise.race([p1_1, p2, p3])
pRace1.then(
    value => { console.log("all onResolved()", value) }, // all onResolved() 2
    reason => { console.log("all onRejected()", reason) }
)
const pRace2 = Promise.race([p3, p1, p2])
pRace2.then(
    value => { console.log("all onResolved()", value) },
    reason => { console.log("all onRejected()", reason) } // all onRejected() 3
)
</script>
</body>
</html>